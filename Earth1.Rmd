---
title: "Introduction to **tidyverse** ecosystem"
output:
  html_document:
    toc: true
---

#  Introduction 

### Load the *core* ```tidyverse``` packages


```{r}
library(tidyverse)
```

### ```tibble```

R convert columns that are detected to be character/strings to be factor variables. **```tibble```** has as default mode the ```stringsAsFactors = FALSE``` 

```{r}
envData <- as_tibble(readRDS("/home/kfsgiorgos/EarthBias2017/spanishPrecipRecords.RDS"))
stationsData <- as_tibble(readRDS("/home/kfsgiorgos/EarthBias2017/precipStations.RDS"))
dplyr::glimpse(envData)
```
   

* Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. 
* Tibbles are one of the unifying features of the ```tidyverse```.
* ```tibble()``` in contrast to ````data.frame()``` does much less: it *never changes the type of the inputs* (e.g. it never converts strings to factors!), it *never changes the names of variables, and it never creates row names.*    
* Tibble subsetting **[** always returns another tibble. Data frame subsetting **[** sometimes returns a data frame and sometimes it just returns a vector.
```{r}
class(envData[, 1:2])
```
```{r}
class(envData[, 1])
```

### ```dplyr```, ```magrittr``` & ```lubridate```

**```dplyr```** package works with structured data and is built around 5 verbs which make up the majority of the data manipulation. 

* **```Select```** certain columns.
* **```Filter```** to select specific rows.
* **```Arrange```** the rows into an order.
* **```Mutate```** to create new columns.
* **```Summarise```** many values down to a single summary.

**```magrittr```** comes with the pipe **```%>%```** and it is a powerful tool for chaining multiple operations. The point of the pipe is to help you write code in a way that easier to read and understand.

**```lubridate```** simplifies parsing dates and times by handling a wide variety of formats and seperators. It is not part of core tidyverse so we have to load it manually. 

Conditional subset using **```dplyr```**
```{r}
dplyr::filter(envData, STAID == "229" & RR > 100)
```
Conditional subset using **```dplyr```** & **```magrittr```**
```{r}
envData %>% dplyr::filter(STAID %in% c("236", "230") & RR > 100)
```

### Update columns 

We can easily parse dates using **```lubridate```** functions and reassign the result with **```mutate```** verb 
```{r, eval=FALSE}
# load lubridate
library(lubridate)
```

```{r}
envData <- dplyr::mutate(envData, DATE = lubridate::ymd(DATE))
glimpse(envData)
```

### Create new columns 
When we are dealing with dates, there are two appoaches on how to create new columns.

* First approach: use **```tidyr```** package to **separate** the DATE column and each part is a new column.

```{r}
# Track the computational time for seperate operation
approach1 <- system.time(envData1 <- tidyr::separate(envData, DATE, c("Year", "Month", "Day")))
dplyr::glimpse(envData1)
```
* Second approach:  use **```mutate```** verb to create the new columns manually.
```{r}
# Track the computational time for each operation
appoach21 <- system.time(envData <- dplyr::mutate(envData, Year = lubridate::year(DATE)))
appoach22 <- system.time(envData <- dplyr::mutate(envData, Month = lubridate::month(DATE)))
appoach23 <- system.time(envData <- dplyr::mutate(envData, Day = lubridate::day(DATE)))
dplyr::glimpse(envData1)

```
* The comparison between the two approaches shows that the second is by far more efficient. 
```{r, echo=FALSE}
paste0("1st approach time: ", round(approach1[[3]], 2), " vs ", "2nd approach time: ", round(appoach21[[3]] + appoach22[[3]] + appoach23[[3]]), 2)
```
















