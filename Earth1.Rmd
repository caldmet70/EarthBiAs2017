---
title: "Introduction to **tidyverse** ecosystem"
output:
  html_document:
    toc: true
---

#  Introduction 

### Load the *core* ```tidyverse``` packages


```{r}
library(tidyverse)
```

### ```tibble```

R convert columns that are detected to be character/strings to be factor variables. **```tibble```** has as default mode the ```stringsAsFactors = FALSE``` 

```{r}
envData <- as_tibble(readRDS("/home/kfsgiorgos/EarthBias2017/spanishPrecipRecords.RDS"))
stationsData <- as_tibble(readRDS("/home/kfsgiorgos/EarthBias2017/precipStations.RDS"))
dplyr::glimpse(envData)
```
   

* Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. 
* Tibbles are one of the unifying features of the ```tidyverse```.
* ```tibble()``` in contrast to ````data.frame()``` does much less: it *never changes the type of the inputs* (e.g. it never converts strings to factors!), it *never changes the names of variables, and it never creates row names.*    
* Tibble subsetting **[** always returns another tibble. Data frame subsetting **[** sometimes returns a data frame and sometimes it just returns a vector.
```{r}
class(envData[, 1:2])
```
```{r}
class(envData[, 1])
```

### ```dplyr```, ```magrittr``` & ```lubridate```

**```dplyr```** package works with structured data and is built around 5 verbs which make up the majority of the data manipulation. 

* **```Select```** certain columns.
* **```Filter```** to select specific rows.
* **```Arrange```** the rows into an order.
* **```Mutate```** to create new columns.
* **```Summarise```** many values down to a single summary.

**```magrittr```** comes with the pipe ```%>%``` and it is a powerful tool for chaining multiple operations. The point of the pipe is to help you write code in a way that easier to read and understand.

**```lubridate```** simplifies parsing dates and times by handling a wide variety of formats and seperators. ```lubridate``` is not part of core tidyverse so we have to load it manually. 

```{r, echo=FALSE}
# load lubridate
library(lubridate)
```
# Conditional subset using dplyr
```{r}
filter(envData, STAID == "229" & RR > 100)
```
# Conditional subset using dplyr & pipe
```{r}
envData %>% filter(STAID == "229" & RR > 100)
```
# Update column using dplyr, pipes & lubridate
```{r}
envData <- envData %>% dplyr::mutate(DATE = lubridate::ymd(DATE))
envData
```

### Update columns 

We can easily parse dates using ```lubridate``` functions and reassign the result with ```mutate``` verb 
```{r}
envData <- dplyr::mutate(envData, DATE = lubridate::ymd(DATE))
```

### Create new columns 
When we are dealing with dates, there are two appoaches on how to create new columns.

* First approach: use ```mutate``` with the time intervals that are under your interest.
```{r}
# Track the computational time for each operation
appoach11 <- system.time(envData1 <- dplyr::mutate(envData, Year = lubridate::year(DATE)))
appoach12 <- system.time(envData1 <- dplyr::mutate(envData1, Month = lubridate::month(DATE)))
appoach13 <- system.time(envData1 <- dplyr::mutate(envData1, Day = lubridate::day(DATE)))
dplyr::glimpse(envData1)
```
* Second approach:  use ```tidyr``` package to achieve the same result as above but it is by far slower than the first approach.
```{r}
# Track the computational time for seperate operation
approach2 <- system.time(envData2 <- tidyr::separate(envData, DATE, c("Year", "Month", "Day")))
dplyr::glimpse(envData2)
```
* We quantify the computational time difference between the two approaches
```{r}
appoach11[[3]] + appoach12[[3]] + appoach13[[3]] 
```

```{r}
approach2[[3]] 
```














